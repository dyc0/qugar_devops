# --------------------------------------------------------------------------
#
# Copyright (C) 2025-present by Pablo Antolin
#
# This file is part of the QUGaR library.
#
# SPDX-License-Identifier:    MIT
#
# --------------------------------------------------------------------------

"""A few functionalities for parsing C code generated by FFCx."""

from qugar.utils import has_FEniCSx

if not has_FEniCSx:
    raise ValueError("FEniCSx installation not found is required.")

from typing import cast

import numpy as np


def get_pairing_brackets(
    code: str, open_bracket: str = "{", close_bracket: str = "}"
) -> tuple[int, int]:
    """Given a piece of `code`, finds the index positions in the code's
    string of a couple of (opening and closing) matching brackets.

    It finds the first occurrence of the opening bracket and then finds
    its closing match. Other brackets may open (and close) inside the
    the exterior pair.

    Args:
        code (str): Code in which the brackets are sought.
        open_bracket (str, optional): Opening bracket. Defaults to
            ``{``.
        close_bracket (str, optional): Closing bracket. Defaults to
            ``}``.

    Raises:
        ValueError: Raises and error if no opening and matching
            closing brackets were found.

    Returns:
        tuple[int, int]: The first entry corresponds to the position of
        the opening bracket in the given `code` string, and the second
        one to the position of the closing bracket.
    """

    start = 0
    n_open = 0
    for i in range(len(code)):
        if code[i] == open_bracket:
            if n_open == 0:
                start = i
            n_open += 1
        elif code[i] == close_bracket:
            n_open -= 1
            if n_open == 0:
                return start, i + 1
    assert False, "Not matching brackets found"


def dtype_to_C_str(
    dtype: type[np.float32 | np.float64 | float | np.complex64 | np.complex128],
) -> str:
    """Transforms a `numpy` floating type (real or complex) to a string
    representing the type in C language.

    Args:
        dtype (type[np.float32 | np.float64 | float | np.complex64 | np.complex128]):
            `numpy` type to transform.

    Raises:
        ValueError: If the given type is not a ``np.float32``,
            ``np.float64``, ``float`` ``np.complex64``, or ``np.complex128``, an
            exception is raised.

    Returns:
        str: String representing the C type associated to dtype.
    """

    if np.issubdtype(dtype, np.float32):
        return "float"
    elif np.issubdtype(dtype, np.float64) or np.issubdtype(dtype, float):
        return "double"
    elif np.issubdtype(dtype, np.complex64):
        return "float _Complex"
    elif np.issubdtype(dtype, np.complex128):
        return "double _Complex"
    else:
        raise ValueError(
            f"Invalid dtype {dtype}. It must be float, np.float32, "
            "np.float64, np.complex64, or np.complex128."
        )


def parse_dtype_C(
    dtype_str: str,
) -> type[np.float32 | np.float64 | np.complex64 | np.complex128]:
    """Transforms a string representing a (real or complex) floating
    type into a `numpy` type.

    Args:
        dtype_str (str): String reresenting a (real or complex)
            floating type.

    Raises:
        ValueError: So far, only the types ``float``, ``double``,
            ``float32``, ``float64``, ``complex float``,
            ``complex double``, ``float _Complex``, ``double _Complex``,
            ``complex64``, and ``complex128`` are supported. If
            `dtype_str` does not match any of those, an exception is
            raised.

    Returns:
        type[np.float32 | np.float64 | np.complex64 | np.complex128]: `numpy`
            type corresponding to the given string `dtype_str`.
    """

    np_type = np.float32
    if dtype_str in ["float", "float32"]:
        np_type = np.float32
    elif dtype_str in ["double", "float64"]:
        np_type = np.float64
    elif dtype_str in ["complex float", "float _Complex", "complex64"]:
        np_type = np.complex64
    elif dtype_str in ["complex double", "double _Complex", "complex128"]:
        np_type = np.complex128
    else:
        raise ValueError(
            f"Invalid dtype {dtype_str}. It must be float, double, "
            "float32, float64, complex float, complex double, "
            "float _Complex, double _Comples, complex64, or complex128."
        )
    return np_type


def parse_real_dtype_from_C(
    dtype_str: str,
) -> type[np.float32 | np.float64]:
    """Transforms a string representing a real floating type into a
    `numpy` type.

    Args:
        dtype_str (str): String reresenting a real floating type.

    Raises:
        ValueError: So far, only the types ``float``, ``double``,
            ``float32`` and ``float64`` are supported. If `dtype_str`
            does not match one of those, an exception is raised.

    Returns:
        type[np.float32 | np.float64]: `numpy` type corresponding to the given
            string.
    """

    dtype = cast(type[np.float32 | np.float64], parse_dtype_C(dtype_str))
    if dtype not in [np.float32, np.float64]:
        raise ValueError(
            f"Invalid dtype {dtype_str}. It must be float, double, float32, or float64."
        )
    return dtype
