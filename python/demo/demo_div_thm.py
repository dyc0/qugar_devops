# --------------------------------------------------------------------------
#
# Copyright (C) 2025-present by Pablo Antolin
#
# This file is part of the QUGaR library.
#
# SPDX-License-Identifier:    MIT
#
# --------------------------------------------------------------------------

"""This is file is just a demo of the capabilities of the QUGaR-Python interface
using FEniCSx machinery.

To illustrate the capabilities, it creates different implicit domains (in 2D and 3D)
and verifies the divergence theorem by computing the volumetric and surface integrals of a vector
field and its divergence over the domain.
It computes such integrals through the quadrature points, weights, and normals generated by QUGaR.

The computation of these integrals involves using the generated quadrature points and weights in
the case of the volumetric integral, and the quadrature points, weights, and normals in the case of
the integral over the levelset surface and domain facets.

It also writes a representation of the quadrature, and a reparameterization of the domain
to VTK files for visualization, if the VTK library is found.
These files can be visualized using a VTK-compatible viewer, such as ParaView.
"""

import qugar.utils

if not qugar.has_FEniCSx:
    raise ValueError("FEniCSx installation not found is required.")


from typing import Optional, Tuple, cast

from mpi4py import MPI

import dolfinx.fem
import dolfinx.mesh
import numpy as np
import ufl

import qugar
import qugar.cpp
import qugar.utils
from qugar.dolfinx import CustomForm, dx_bdry_int, form_custom, mapped_normal
from qugar.impl import ImplicitFunc, UnfittedImplDomain
from qugar.mesh import create_Cartesian_mesh
from qugar.quad import create_quadrature_generator
from qugar.reparam import create_reparam_mesh

n_quad_pts = 5
dtype = np.float64


def create_vector_func(dlf_mesh: dolfinx.mesh.Mesh) -> ufl.Coefficient:
    """
    Create a vector function for testing the divergence theorem.

    Args:
        dlf_mesh (dolfinx.mesh.Mesh): The input mesh for which the UFL function is created.

    Returns:
        ufl.Coefficient: The generated UFL vector field as a coefficient.
    """
    x = ufl.SpatialCoordinate(dlf_mesh)

    comps = []
    for i in range(dlf_mesh.geometry.dim):
        comps.append(ufl.sin(x[i]) if i % 2 == 0 else ufl.cos(x[i]))  # type: ignore
    return ufl.as_vector(comps)  # type: ignore


def create_unf_domain(
    impl_func: ImplicitFunc,
    n_cells: Optional[list[int]] = None,
) -> UnfittedImplDomain:
    """
    Creates an unfitted implicit domain based on the provided implicit function and number of cells.

    Args:
        impl_func (ImplicitFunc): The implicit function defining the domain.
        n_cells (Optional[list[int]]): A list specifying the number of cells in each dimension.
                                       If None, defaults to [16] * dim, where dim is the dimension
                                       of the implicit function.

    Returns:
        UnfittedImplDomain: The resulting unfitted implicit domain.
    """
    dim = impl_func.dim
    if n_cells is None:
        n_cells = cast(list[int], [16] * dim)

    dim = impl_func.dim
    comm = MPI.COMM_WORLD
    xmin = np.zeros(dim, dtype)
    xmax = np.ones(dim, dtype)
    cart_mesh = create_Cartesian_mesh(
        comm,
        n_cells,
        xmin,
        xmax,
    )

    return qugar.impl.create_unfitted_impl_domain(impl_func, cart_mesh)


def verify_divergenge_theorem_volume(
    unf_domain: UnfittedImplDomain,
) -> dtype:
    """
    Verifies the divergence theorem over a given volume.

    This function computes the volume integral of the divergence of a vector field
    over a domain defined by an implicit function and an unfitted implicit domain. It uses
    quadrature points to approximate the integral.

    Args:
        unf_domain (UnfittedImplDomain): The unfitted implicit domain of the domain.

    Returns:
        dtype: The computed volume integral.
    """

    dlf_mesh = unf_domain.cart_mesh.dolfinx_mesh
    div_func = ufl.div(create_vector_func(dlf_mesh))

    tag = 0
    cell_tags = unf_domain.create_cell_tags(cut_tag=tag, full_tag=tag)

    dx = ufl.dx(
        subdomain_id=tag,
        domain=dlf_mesh,
        subdomain_data=cell_tags,
    )
    ufl_form = div_func * dx

    form = form_custom(ufl_form, dtype=dtype)
    assert isinstance(form, CustomForm)

    quad_gen = create_quadrature_generator(unf_domain)

    return dolfinx.fem.assemble_scalar(form, coeffs=form.pack_coefficients(quad_gen))


def verify_divergenge_theorem_surface(
    unf_domain: UnfittedImplDomain,
) -> dtype:
    """
    Verifies the divergence theorem on a surface by computing the surface integral.

    Args:
        unf_domain (UnfittedImplDomain): The unfitted implicit domain of the domain.

    Returns:
        dtype: The computed surface integral.
    """

    dlf_mesh = unf_domain.cart_mesh.dolfinx_mesh

    tag = 0
    cell_tags = unf_domain.create_cell_tags(cut_tag=tag)
    facet_tags = unf_domain.create_facet_tags(cut_tag=tag, full_tag=tag)

    ds_int = dx_bdry_int(domain=dlf_mesh, subdomain_data=cell_tags, subdomain_id=tag)
    ds = ufl.ds(domain=dlf_mesh, subdomain_data=facet_tags, subdomain_id=tag)

    bound_normal = mapped_normal(dlf_mesh)
    facet_normal = ufl.FacetNormal(dlf_mesh)
    func = create_vector_func(dlf_mesh)

    ufl_form = ufl.inner(func, bound_normal) * ds_int + ufl.inner(func, facet_normal) * ds
    form = form_custom(ufl_form, dtype=dtype)
    assert isinstance(form, CustomForm)

    quad_gen = create_quadrature_generator(unf_domain)

    return dolfinx.fem.assemble_scalar(form, coeffs=form.pack_coefficients(quad_gen))


def verify_divergenge_theorem(
    domain: UnfittedImplDomain,
) -> Tuple[dtype, dtype]:
    """
    Verifies the divergence theorem by comparing volume and surface integrals.

    Args:
        domain (UnfittedImplDomain): The unfitted implicit domain.
        n_cells (Optional[list[int]]): Number of cells for unfitted implicit domain.
            Defaults to None.

    Returns:
        Tuple[dtype, dtype]: The volume integral and surface integral values.
    """
    vol_integr = verify_divergenge_theorem_volume(domain)
    srf_integr = verify_divergenge_theorem_surface(domain)
    return vol_integr, srf_integr


if qugar.has_VTK:

    def dump_to_VTK(domain: UnfittedImplDomain, name_prefix: str) -> None:
        """
        Dumps the given unfitted implicit domain to VTK files for visualization,
        It exports a generated reparameterization mesh data and quadrature points to VTK files.

        Args:
            domain (UnfittedImplDomain): The unfitted implicit domain to be visualized.
            name_prefix (str): The prefix for the output VTK file names.

        Returns:
            None
        """
        reparam = create_reparam_mesh(domain, n_pts_dir=n_quad_pts)
        reparam.to_VTK_file(f"{name_prefix}_reparam")

        reparam_levelset = create_reparam_mesh(domain, n_pts_dir=n_quad_pts, levelset=True)
        reparam_levelset.to_VTK_file(f"{name_prefix}_levelset_reparam")

        domain.quadrature_to_VTK_file(f"{name_prefix}_quad", n_pts_dir=n_quad_pts)


def test(impl_func: ImplicitFunc, n_cells: list[int], name_prefix: str):
    """
    Tests the divergence theorem for a given implicit function.

    Args:
        impl_func (ImplicitFunc): The implicit function to test.
        n_cells (list[int]): A list of integers representing the number of cells in each dimension.
        name_prefix (str): The prefix for naming output files.

    Returns:
        None

    Prints:
        The volumetric integral and surface integral.

    If VTK is found, dumps the implicit function reparameterization and quadrature to VTK files.
    """

    domain = create_unf_domain(impl_func, n_cells)

    vol_intgr, srf_intgr = verify_divergenge_theorem(domain)

    print(f"  - Volumetric integral: {vol_intgr}")
    print(f"  - Surface integral: {srf_intgr}")

    if qugar.has_VTK:
        dump_to_VTK(domain, name_prefix)


if __name__ == "__main__":
    print("Disk - divergence theorem verification")
    radius = 0.6
    center = np.array([-0.25, 0.15])
    func = qugar.impl.create_disk(center=center, radius=radius)
    n_cells = [16] * 2
    test(func, n_cells, "disk")
    print()

    print("Sphere - divergence theorem verification")
    radius = 0.7
    center = np.array([0.25, 0.35, 0.45])
    func = qugar.impl.create_sphere(center=center, radius=radius)
    n_cells = [16] * 3
    test(func, n_cells, "sphere")
    print()
