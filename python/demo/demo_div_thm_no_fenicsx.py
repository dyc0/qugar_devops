# --------------------------------------------------------------------------
#
# Copyright (C) 2025-present by Pablo Antolin
#
# This file is part of the QUGaR library.
#
# SPDX-License-Identifier:    MIT
#
# --------------------------------------------------------------------------

"""This is file is just a demo of the capabilities of the QUGaR-Python interface
without requiring FEniCSx dependencies.

To illustrate the capabilities, it creates different implicit domains (in 2D and 3D)
and verifies the divergence theorem by computing the volumetric and surface integrals of a vector
field and its divergence over the domain.
It computes such integrals through the quadrature points, weights, and normals generated by QUGaR.

The computation of these integrals involves using the generated quadrature points and weights in
the case of the volumetric integral, and the quadrature points, weights, and normals in the case of
the integral over the levelset surface and domain facets.

It also writes a representation of the quadrature, and a reparameterization of the domain
to VTK files for visualization, if the VTK library is found.
These files can be visualized using a VTK-compatible viewer, such as ParaView.
"""

from typing import Callable, Optional, Tuple, TypeAlias, cast

import numpy as np
import numpy.typing as npt

import qugar
import qugar.cpp
import qugar.utils

ImplicitFunc: TypeAlias = qugar.cpp.ImplicitFunc_2D | qugar.cpp.ImplicitFunc_3D
UnfittedDomain: TypeAlias = qugar.cpp.UnfittedImplDomain_2D | qugar.cpp.UnfittedImplDomain_3D
ReparamMesh: TypeAlias = (
    qugar.cpp.ReparamMesh_1_2
    | qugar.cpp.ReparamMesh_2_2
    | qugar.cpp.ReparamMesh_2_3
    | qugar.cpp.ReparamMesh_3_3
)
Func = Callable[[npt.NDArray[np.floating]], npt.NDArray[np.floating]]
DivFunc = Callable[[npt.NDArray[np.floating]], npt.NDArray[np.floating]]


def create_reparam(
    unf_domain: UnfittedDomain,
    n_pts_dir: Optional[int] = 4,
    levelset: Optional[bool] = False,
) -> ReparamMesh:
    """
    Creates a reparameterization of the given implicit function on the specified unfitted
    implicit domain.

    Args:
        unf_domain (UnfittedDomain): The unfitted implicit domain to be used for reparameterization.
        n_pts_dir (Optional[int], optional): Number of points in each direction for the grid.
             Defaults to 4.
        levelset (Optional[bool], optional): Whether to use the level set reparameterization
            algorithm. Defaults to False.

    Returns:
        ReparamMesh: The reparameterized implicit function.
    """
    algo = (
        qugar.cpp.create_reparameterization_levelset
        if levelset
        else qugar.cpp.create_reparameterization
    )
    return algo(unf_domain, n_pts_dir)


def scale_points_from_01(
    domain: npt.NDArray[np.float64], points: npt.NDArray[np.float64]
) -> npt.NDArray[np.float64]:
    """
    Scales points from the unit interval [0, 1] to a specified domain.

    Args:
        domain (npt.NDArray[np.float64]): A 2D array where each row represents the
            [min, max] range for each dimension.
        points (npt.NDArray[np.float64]): A 2D array of points to be scaled, where
            each row is a point and each column corresponds to a dimension.

    Returns:
        npt.NDArray[np.float64]: A 2D array of scaled points.
    """
    dim = points.shape[1]
    scaled_points = np.empty_like(points)
    for dir in range(dim):
        scaled_points[:, dir] = domain[dir, 0] + points[:, dir] * (domain[dir, 1] - domain[dir, 0])
    return scaled_points


def find_facets_on_boundary(
    unf_domain: UnfittedDomain,
    cells: npt.NDArray[np.int32],
    facets: npt.NDArray[np.int32],
    facet_id: int,
) -> npt.NDArray[np.int32]:
    """
    Among the given cells (and associated facets), finds (and returns) the cells whose
    facets are equal to facet_id.

    Args:
        unf_domain (UnfittedDomain): The unfitted implicit domain object containing the grid.
        cells (npt.NDArray[np.int32]): Array of cell indices.
        facets (npt.NDArray[np.int32]): Array of facet indices corresponding to the cells.
        facet_id (int): The ID of the facet to find among the cells.

    Returns:
        npt.NDArray[np.int32]: Array of cell indices that have have an associated facet id
        equal to facet_id.
    """
    cells = cells[np.where(facets == facet_id)]

    grid = unf_domain.grid
    bound_cells = grid.get_boundary_cells(facet_id)
    indices = np.where(np.isin(cells, bound_cells))[0]
    return cells[indices]


def find_full_facets_on_boundary(
    unf_domain: UnfittedDomain, facet_id: int
) -> npt.NDArray[np.int32]:
    """
    Find full facets on the boundary of an unfitted implicit domain that have the
    given local facet_id.

    This function retrieves the full facets from the given unfitted implicit domain
    and identifies which of these facets are on the boundary based on the
    provided facet ID.

    Args:
        unf_domain (UnfittedDomain): The unfitted implicit domain object containing
            the grid data.
        facet_id (int): The ID of the facet to check for boundary status.

    Returns:
        npt.NDArray[np.int32]: An array of cell IDs associated fo the facets.
    """
    cells, facets = unf_domain.full_facets
    return find_facets_on_boundary(unf_domain, cells, facets, facet_id)


def find_cut_facets_on_boundary(unf_domain: UnfittedDomain, facet_id: int) -> npt.NDArray[np.int32]:
    """
    Find cut facets on the boundary of an unfitted implicit domain that have the
    given local facet_id.

    This function retrieves the cut facets from the given unfitted implicit domain
    and identifies which of these facets are on the boundary based on the
    provided facet ID.

    Args:
        unf_domain (UnfittedDomain): The unfitted implicit domain object containing
            the grid data.
        facet_id (int): The ID of the facet to check for boundary status.

    Returns:
        npt.NDArray[np.int32]: An array of cell IDs associated fo the facets.
    """
    cells, facets = unf_domain.cut_facets
    return find_facets_on_boundary(unf_domain, cells, facets, facet_id)


def create_facet_quadrature(
    facet_points: npt.NDArray[np.float64],
    facet_weights: npt.NDArray[np.float64],
    facet_id: int,
) -> Tuple[npt.NDArray[np.float64], npt.NDArray[np.float64], npt.NDArray[np.float64]]:
    """
    Create quadrature points, weights, and normals for a given facet id.

    Extends the points from the facet to the higher-dimensional space by adding
    the constant coordinate of the facet.
    It also generated the (constant) normal vectors for the quadrature points.

    Note:
        The weights are not modified.

    Args:
        facet_points (npt.NDArray[np.float64]): Array of points on the facet.
        facet_weights (npt.NDArray[np.float64]): Array of weights for the quadrature points.
        facet_id (int): Identifier for the facet, used to determine the constant direction and side.

    Returns:
        Tuple[npt.NDArray[np.float64], npt.NDArray[np.float64], npt.NDArray[np.float64]]:
            - points: Array of quadrature points in the higher-dimensional space.
            - facet_weights: Array of weights for the quadrature points.
            - normals: Array of normal vectors for the quadrature points.
    """
    facet_dim = facet_points.shape[1]
    dim = facet_dim + 1
    dtype = facet_points.dtype

    const_dir = facet_id // 2
    side = facet_id % 2

    points = np.zeros((facet_points.shape[0], dim), dtype=dtype)

    points[:, const_dir] = dtype.type(side)
    local_dir = 0
    for dir in range(dim):
        if dir != const_dir:
            points[:, dir] = facet_points[:, local_dir]
            local_dir += 1

    normals = np.zeros_like(points)
    normals[:, const_dir] = dtype.type(1.0) if side == 1 else dtype.type(-1.0)

    return points, facet_weights, normals


def create_full_facet_quadrature(
    dim: int, facet_id: int, n_quad_pts: int
) -> Tuple[npt.NDArray[np.float64], npt.NDArray[np.float64], npt.NDArray[np.float64]]:
    """
    Create a full facet quadrature for a given dimension and facet.

    Args:
        dim (int): The dimension of the space.
        facet_id (int): The identifier of the facet.
        n_quad_pts (int): The number of quadrature points per direction.

    Returns:
        Tuple[npt.NDArray[np.float64], npt.NDArray[np.float64], npt.NDArray[np.float64]]:
            - points: Array of quadrature points in the higher-dimensional space.
            - facet_weights: Array of weights for the quadrature points.
            - normals: Array of normal vectors for the quadrature points.
    """
    quad = qugar.cpp.create_Gauss_quad_01([n_quad_pts] * (dim - 1))
    return create_facet_quadrature(quad.points, quad.weights, facet_id)


def create_unf_domain(
    impl_func: ImplicitFunc,
    n_cells: Optional[list[int]] = None,
) -> UnfittedDomain:
    """
    Creates an unfitted implicit domain based on the provided implicit function and number of cells.

    Args:
        impl_func (ImplicitFunc): The implicit function defining the domain.
        n_cells (Optional[list[int]]): A list specifying the number of cells in each dimension.
                                       If None, defaults to [16] * dim, where dim is the dimension
                                       of the implicit function.

    Returns:
        UnfittedDomain: The resulting unfitted implicit domain.
    """
    dim = impl_func.dim
    if n_cells is None:
        n_cells = cast(list[int], [16] * dim)

    cell_breaks = [np.linspace(0.0, 1.0, n_cells[dir] + 1) for dir in range(dim)]

    grid = qugar.cpp.create_cart_grid(cell_breaks)
    return qugar.cpp.create_unfitted_impl_domain(impl_func, grid)


def verify_divergenge_theorem_volume(
    impl_func: ImplicitFunc,
    unf_domain: UnfittedDomain,
    div_func: DivFunc,
    n_quad_pts: int,
) -> np.float64:
    """
    Verifies the divergence theorem over a given volume.

    This function computes the volume integral of the divergence of a vector field
    over a domain defined by an implicit function and an unfitted implicit domain. It uses
    quadrature points to approximate the integral.

    Args:
        impl_func (ImplicitFunc): The implicit function defining the domain.
        unf_domain (UnfittedDomain): The unfitted implicit domain of the domain.
        div_func (DivFunc): The divergence function to be integrated.
        n_quad_pts (int): The number of quadrature points per direction to use.

    Returns:
        np.float64: The computed volume integral.
    """
    grid = unf_domain.grid
    quad = qugar.cpp.create_quadrature(
        unf_domain,
        unf_domain.cut_cells,
        n_quad_pts,
    )

    dim = impl_func.dim
    quad_01 = qugar.cpp.create_Gauss_quad_01([n_quad_pts] * dim)

    def compute_cell_integr(points, weights, cell_id):
        domain = grid.get_cell_domain(cell_id)
        cell_volume = domain.volume
        vals = div_func(scale_points_from_01(domain.as_array(), points))
        return np.dot(vals, weights) * cell_volume

    vol_integr = np.float64(0.0)
    for cell_id in unf_domain.full_cells:
        vol_integr += compute_cell_integr(quad_01.points, quad_01.weights, cell_id)

    pt_id = 0
    for cell_id, n_pts in zip(quad.cells, quad.n_pts_per_entity):
        pt_id_1 = pt_id + n_pts
        weights = quad.weights[pt_id:pt_id_1]
        points = quad.points[pt_id:pt_id_1]
        pt_id = pt_id_1

        vol_integr += compute_cell_integr(points, weights, cell_id)

    return vol_integr


def verify_divergenge_theorem_surface(
    impl_func: ImplicitFunc,
    unf_domain: UnfittedDomain,
    func: Func,
    n_quad_pts: int,
) -> np.float64:
    """
    Verifies the divergence theorem on a surface by computing the surface integral.

    Args:
        impl_func (ImplicitFunc): The implicit function defining the domain (the surface
          is the function's levelset).
        unf_domain (UnfittedDomain): The unfitted implicit domain of the domain.
        func (Func): The function to be integrated over the surface.
        n_quad_pts (int): The number of quadrature points per direction to use for integration.

    Returns:
        np.float64: The computed surface integral.
    """
    dim = impl_func.dim
    grid = unf_domain.grid

    def compute_srf_integral(points, weights, normals, cell_id):
        cell_domain = grid.get_cell_domain(cell_id)
        vals = func(scale_points_from_01(cell_domain.as_array(), points))

        cell_volume = cell_domain.volume
        mapped_normals = np.empty_like(normals)
        for dir in range(dim):
            mapped_normals[:, dir] = normals[:, dir] / cell_domain.length(dir)
        scaled_weights = weights * np.linalg.norm(mapped_normals, axis=1) * cell_volume

        return np.dot(np.sum(vals * normals, axis=1), scaled_weights)

    srf_intgr = np.float64(0.0)

    for facet_id in range(dim * 2):
        full_facets = find_full_facets_on_boundary(unf_domain, facet_id)
        points, weights, normals = create_full_facet_quadrature(dim, facet_id, n_quad_pts)

        for cell_id in full_facets:
            srf_intgr += compute_srf_integral(points, weights, normals, cell_id)

        cells = find_cut_facets_on_boundary(unf_domain, facet_id)
        facets = np.full_like(cells, facet_id)
        facet_quad = qugar.cpp.create_facets_quadrature(unf_domain, cells, facets, n_quad_pts)

        pt_id = 0
        for cell_id, n_pts in zip(facet_quad.cells, facet_quad.n_pts_per_entity):
            pt_id_1 = pt_id + n_pts
            facet_points = facet_quad.points[pt_id:pt_id_1]
            facet_weights = facet_quad.weights[pt_id:pt_id_1]
            points, weights, normals = create_facet_quadrature(
                facet_points, facet_weights, facet_id
            )
            pt_id = pt_id_1

            srf_intgr += compute_srf_integral(points, weights, normals, cell_id)

    quad = qugar.cpp.create_interior_bound_quadrature(
        unf_domain,
        unf_domain.cut_cells,
        n_quad_pts,
    )

    pt_id = 0
    for cell_id, n_pts in zip(quad.cells, quad.n_pts_per_entity):
        pt_id_1 = pt_id + n_pts
        weights = quad.weights[pt_id:pt_id_1]
        normals = quad.normals[pt_id:pt_id_1]
        points = quad.points[pt_id:pt_id_1]
        pt_id = pt_id_1

        srf_intgr += compute_srf_integral(points, weights, normals, cell_id)

    return srf_intgr


def verify_divergenge_theorem(
    impl_func: ImplicitFunc,
    func: Func,
    div_func: DivFunc,
    n_quad_pts: int,
    n_cells: Optional[list[int]] = None,
) -> Tuple[np.float64, np.float64]:
    """
    Verifies the divergence theorem by comparing volume and surface integrals.

    Args:
        impl_func (ImplicitFunc): The implicit function defining the domain.
        func (Func): The vector field function.
        div_func (DivFunc): The divergence of the vector field function.
        n_quad_pts (int): Number of quadrature points per direction for numerical integration.
        n_cells (Optional[list[int]]): Number of cells for unfitted implicit domain.
            Defaults to None.

    Returns:
        Tuple[np.float64, np.float64]: The volume integral and surface integral values.
    """
    unf_domain = create_unf_domain(impl_func, n_cells)
    vol_integr = verify_divergenge_theorem_volume(impl_func, unf_domain, div_func, n_quad_pts)
    srf_integr = verify_divergenge_theorem_surface(impl_func, unf_domain, func, n_quad_pts)
    return vol_integr, srf_integr


n_quad_pts = 5


def test_func(x: npt.NDArray[np.floating]) -> npt.NDArray[np.floating]:
    """
    Vector field function for testing the divergence theorem.

    Args:
        x (npt.NDArray[np.floating]): Input array of floating point numbers.

    Returns:
        npt.NDArray[np.floating]: Array with the same shape as `x`, where each element is the sine
        of the corresponding element in `x` if it is in an even-indexed column, or the cosine if it
        is in an odd-indexed column.
    """
    vals = np.empty_like(x)
    for i in range(x.shape[1]):
        vals[:, i] = np.sin(x[:, i]) if i % 2 == 0 else np.cos(x[:, i])
    return vals


def test_div_func(x: npt.NDArray[np.floating]) -> npt.NDArray[np.floating]:
    """
    Scalar field function for testing the divergence theorem.
    It is the divergence of the `test_func`.

    Args:
        x (npt.NDArray[np.floating]): A 2D numpy array of floating point numbers.

    Returns:
        npt.NDArray[np.floating]: A 1D numpy array containing the computed values.
    """
    vals = np.zeros(x.shape[0], dtype=x.dtype)
    for i in range(x.shape[1]):
        vals += np.cos(x[:, i]) if i % 2 == 0 else -np.sin(x[:, i])
    return vals


if qugar.has_VTK:

    def dump_to_VTK(impl_func: ImplicitFunc, n_cells: list[int], name_prefix: str) -> None:
        """
        Dumps the given implicit function to VTK files for visualization.

        This function creates a unfitted implicit domain and reparameterizes the implicit function.
        It then exports the reparameterized data and quadrature points to VTK files.

        Args:
            impl_func (ImplicitFunc): The implicit function to be visualized.
            n_cells (list[int]): The number of cells in each direction for the
                unfitted implicit domain.
            name_prefix (str): The prefix for the output VTK file names.

        Returns:
            None
        """

        unf_domain = create_unf_domain(impl_func, n_cells)

        reparam = create_reparam(unf_domain, n_pts_dir=n_quad_pts, levelset=False)
        qugar.vtk.write_VTK_to_file(qugar.vtk.reparam_to_VTK(reparam), f"{name_prefix}_reparam")
        reparam_levelset = create_reparam(unf_domain, n_pts_dir=n_quad_pts, levelset=True)
        qugar.vtk.write_VTK_to_file(
            qugar.vtk.reparam_to_VTK(reparam_levelset), f"{name_prefix}_levelset_reparam"
        )

        qugar.vtk.write_VTK_to_file(
            qugar.vtk.quadrature_to_VTK(unf_domain, n_quad_pts), f"{name_prefix}_quad"
        )


def test(impl_func: ImplicitFunc, n_cells: list[int], name_prefix: str):
    """
    Tests the divergence theorem for a given implicit function.

    Args:
        impl_func (ImplicitFunc): The implicit function to test.
        n_cells (list[int]): A list of integers representing the number of cells in each dimension.
        name_prefix (str): The prefix for naming output files.

    Returns:
        None

    Prints:
        The volumetric integral and surface integral.

    If VTK is found, dumps the implicit function reparameterization and quadrature to VTK files.
    """
    vol_intgr, srf_intgr = verify_divergenge_theorem(
        impl_func, test_func, test_div_func, n_quad_pts, n_cells
    )

    print(f"  - Volumetric integral: {vol_intgr}")
    print(f"  - Surface integral: {srf_intgr}")

    if qugar.has_VTK:
        dump_to_VTK(impl_func, n_cells, name_prefix)


if __name__ == "__main__":
    print("Disk - divergence theorem verification")
    radius = 0.6
    origin = np.array([-0.25, 0.15])
    func = qugar.cpp.create_disk(center=origin, radius=radius)
    n_cells = [16] * 2
    test(func, n_cells, "disk")
    print()

    print("Sphere - divergence theorem verification")
    radius = 0.7
    origin = np.array([0.25, 0.35, 0.45])
    func = qugar.cpp.create_sphere(center=origin, radius=radius)
    n_cells = [16] * 3
    test(func, n_cells, "sphere")
    print()
